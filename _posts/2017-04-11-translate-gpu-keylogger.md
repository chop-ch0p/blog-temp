---
title: '번역: You Can Type, but You Can’t Hide: A Stealthy GPU-based Keylogger'
date: 2017-04-11 00:00:00 Z
tags:
- gpgpu
- 키로거
- 논문 번역
---

이 번역문은 논문의 저자 Michalis Polychronakis의 허가를 받아 게재되었습니다.  
오역 및 오탈자가 있을 수 있습니다.  
원문:  [http://www.cs.columbia.edu/~mikepo/papers/gpukeylogger.eurosec13.pdf](http://www.cs.columbia.edu/~mikepo/papers/gpukeylogger.eurosec13.pdf)

## 개요

키로거는 타이핑된 모든 정보를 기록함으로써 민감한 데이터를 수집하는 대표적인 멀웨어 이다.
<!--more-->
키로거 개발은 백신과 시스템에 의해 탐지되지 않도록 루트킷과 같은 기술을 사용하여 자기 자신을 은닉하는 데 노력하고 있다.
이 논문에서 우리는 은닉된 키로거 개발에 새로운 접근법을 말할 것이다: 우리는 키로거를 동작시키는 환경의 대체 환경으로 그래픽카드의 활용 가능성을 모색할 것이다.
우리의 접근법의 핵심 아이디어는 페이지 테이블의 구조를 수정하거나 커널의 코드를 수정하는 방식이 아닌 GPU의 DMA를 통하여 키보드 버퍼에 직접 적으로 모니터링 하는 방법이다.
우리의 프로토타입 구현의 평가는 GPU 기반의 키로거가 효과적으로 모든 사용자의 키 입력을 기록, GPU 메모리 공간에 그 값을 저장, 기록된 데이터를 매우 적은 런타임 오버헤드를 동반하여 분석할 수 있음을 보여준다.

## 1. 도입

키로거는 몰래 키보드 활동을 기록하거나, 기록된 데이터를 서드파티로 유출하는 가장 심각한 멀웨어 중의 하나이다.
중요한 연구, 업계의 노력에도 불구하고, 키로거는 여전히 개인정보, 금융 정보를 훔치는 중요한 위협이다.
키로거는 작은 하드웨어 장치로 구현 가능하다. 조금 더 편리한 방법으로는 소프트웨어로도 구현할 수 있다.
소프트웨어 키로거는 유저 레벨과 커널 레벨에서 모두 구현할 수 있다.

유저 레벨 키로거는 일반적으로 키보드 입력을 감시하는 고수준 API를 이용한다.
예를 들어, 윈도우는 함수가 불렸을 때 어떤 키가 눌렸는지 안 눌렸는지를 알 수 있거나 혹은 이전 호출 이후 어떤 키가 눌렸는지를 알 수 있는 `GetAsyncKeyState` 함수를 제공한다.
유저 레벨의 키로거는 만들기 쉬운 만큼 후킹 기술을 이용하여 탐지하기도 쉽다.
반면에 커널 레벨의 키로거는 OS 커널에서 돌아가며, 키보드로부터 오는 모든 데이터를 기록한다. 대표적으로 커널 레벨 키로거는 특정 시스템 콜이나 드라이버 함수를 후킹한다.
삽입된 악성코드는 후킹된 함수에서 얻을 수 있는 사용자의 모든 키 입력을 캡쳐한다.
커널 레벨 키로거는 유저 레벨 키로거보다 좀 더 정교하고 은밀하지만, 커널 코드에 매우 의존적이다. 따라서 코드 인증서, 커널 무결성 체크 툴에 의해 탐지될 수 있다.

이 논문에서 우리는 어떻게 멀웨어가 현대 그래픽 프로세서의 연산 능력을 키로깅을 은닉하는데 이용할 수 있는지 보인다.
GPU를 DMA를 통해 키보드 버퍼가 있는 물리 페이지를 조심히 모니터하는 데 이용함으로써, GPU 기반 키로거는 유저의 모든 키입력을 기록, 또 GPU의 메모리에 그 데이터를 저장할 수 있다.
우리 키로거의 중요한 특징은 페이지 테이블을 대체하는 어떠한 커널 수정도 하지 않으며 키보드 버퍼의 물리 주소를 얻기 위해 한 번이라도 커널 내에서 조그만 코드를 실행할 필요가 없다는 점이다.
이 코드는 완벽하게 독립적이다, 어떠한 후킹도 필요 없고 수정하는 것도 없으며 역할이 끝나면 완벽하게 지워진다.
GPU는 유저의 모든 입력을 감시하기 위해 유저 레벨의 제어 프로세스를 통한 DMA를 이용하여 키보드 버퍼의 물리 주소를 사용한다.

우리는 GPU 기반 키로거를 Linux 32-bit, 64-bit 환경에서 구현하였고 검증하였다.
검증 결과 호스트 메모리에서 짧은 시간 동안 존재하는 데이터를 얻기 위한 GPU의 효율성을 보여준다. 그동안 CPU와 GPU 사용량은 최소 수준을 보였으며, 이 연구의 경우 약 0.1%에 해당되었다.
이 논문의 주장:
- 모든 키 입력 이벤트를 감시할 수 있고 해당 데이터를 GPU 메모리에 저장할 수 있는 GPU 키로거를 제시한다.
- GPU 기반의 키로거를 평가하고 모든 키 입력 이벤트를 캡처하는데 효율적인지 증명한다. GPU 커널의 스케줄링 발생을 줄임으로써 키로거는 모든 키 입력 이벤트를 최소한의 오버헤드로 그래픽 출력에 문제를 발생시키지 않으면서 감시할 수 있다.

## 2. 배경지식

GPU에서 일반적인 계산은 지난 몇 년간 큰 폭으로 발전되었다. 역사적으로 GPU는 연산이 많은 명령을 CPU로부터 효과적으로 넘겨받아 2D를 다루거나 3D 그래픽을 렌더링하는데 사용됐다.
끊임없이 성장하는 비디오 게임 업계에 의해 발전되어온 그래픽 프로세서는 연산 성능과 지원된 연산 및 기능면에서 계속 발전해 왔다.
그동안에 개발자는 어플리케이션이 현대 GPU의 대규모 병렬 아키텍쳐가 주는 이점을 활용하기 위한 방법을 찾기 시작했다.

OpenGL과 DirectX 같은 표준 그래픽 API는 그래픽 하드웨어가 제공할 수 있는 연산 성능의 많은 부분을 공개하지 않았다.
알고리즘은 반드시 픽셀 혹은 버텍스 셰이더로 표현되는 반면 데이터와 변수는 그래픽 객체로 매핑되어 진다.
NVIDIA가 개발한 CUDA(Compute Unified Device Architecture) 는 그래픽 API에서 불가능한 몇몇 하드웨어 기능을 제공하는 이점을 가지고 있다.
CUDA는 C언어를 확장한 작은 기능들과 호스트로부터 GPU를 제어할 수 있는 함수들을 제공하는 런타임라이브러리, 장치에 특화된 기능과 데이터 형식으로 이루어져 있다.

최상위 레벨에서 CUDA로 만들어진 응용프로그램은 CPU에서 동작되는 일련의 프로그램과, 커널이라고 부르는 GPU에서 동작하는 병렬적인 부분으로 이루어져 있다.
그러나 커널은 오로지 CPU에서 동작하는 부모 프로세스에 의해서만 실행될 수 있다.
결과적으로 커널은 독립적인 응용프로그램 처럼 시작될 수 없으며 이것을 동작시키는 CPU에 매우 종속적이다.
각각의 커널은 쓰레드블럭 안에서 조직된 매우 다양한 쓰레드처럼 장치에서 실행 된다.
쓰레드 블럭은 GPU의 다중프로세서에 의해 병렬적으로 실행된다.
프로그램 실행 이외에도 CUDA는 호스트와 장치 사이에 데이터를 교환하기위한 적절한 기능을 제공한다.
모든 IO 트랜젝션은 PCI-Express 버스에서 DMA를 통하여 수행된다.
DMA는 GPU가 CPU의 간섭 없이 DMA 엔진을 이용하여 직접적으로 데이터를 주고받을 수 있도록 한다.
일반적으로 GPU는 OS에 의해 할당된 특정 메모리 영역에만 접근할 수 있다.

그래픽 프로세서의 범용 연산 기능의 가능성이 크게 주어지면서, 멀웨어 제작자가 이익을 위하여 현대 GPU의 강력한 기능을 이용하는 것을 예상하는 일은 아주 당연하다.
GPU에서 일반적인 목적의 코드를 실행하는 능력은 기존에 존재하는 방어책에 대항할 기대치를 높이는 새로운 가능성이다.
기존의 악성코드 분석 시스템은 x86 코드를 지원하지만, 현재의 바이러스 검색 툴은 CPU 이외의 프로세서에서 동작하는 코드와 메모리 이외의 분리된 장치에 저장된 코드를 탐지할 수 없다.
게다가 저명한 보안 연구가들은 이 실행환경과 그래픽 프로세서의 명령어에 익숙하지 않다.

GPU의 도움을 받는 악성 실행 파일은 다른 프로세서 위에서 동작하는 코드를 가지고 있다.
실행하는 동안 악성코드는 GPU에 특화된 코드를 불러오고 CPU와 GPU 양쪽에서 접근 가능한 메모리 영역을 할당하며 모든 공유 데이터를 초기화한다. 또한 GPU 코드의 실행을 계획한다.
설계에 따르면 제어의 흐름은 CPU와 GPU 사이에서 앞뒤로 전환될 수 있으며, 각각의 작업은 양쪽의 프로세서에서 병렬적으로 실행될 수 있다.

악성코드 제작자가 가장 유리한 점은 전 세계 시장의 99%가 GPGPU 연산을 지원하는 것이다.
결과적으로 GPU 기반의 악성코드는 지원되지 않는 그래픽 프로세서의 제약 없이 매우 높은 감염률을 가질 수 있다.
더 나아가, 호스트와 장치 간 데이터 전달과 GPU 코드 실행은 어떠한 관리자 권한도 필요가 없다.
즉, GPU의 도움을 받는 악성코드는 목적에 따라 유저권한에서도 성공적으로 실행 될 수 있으므로 더욱 강력하고 쉽게 배포할 수 있다.

![](/images/01/figure-01.png)
*그림 1: 키로거의 임시, 영구적인 구성요소. 회색은 부트스트랩 과정이다. 검은색은 모니터링 함수를 보여준다.*

## 3. GPU 기반 키로깅

이 섹션에서 우리는 GPU를 이용하여 구현된 키로거의 개념증명(PoC)의 자세한 설계를 보여준다.
시스템 함수를 후킹하거나 중요한 자료구조를 다루는 루트킷 비슷한 기술에 의존하는 대신, 우리의 키로거는 GPU로부터 시스템 키보드 버퍼의 내용을 직접적으로 감시한다.

이 설계에 있어 가장 어려운 점 중에 하나는 어떻게 키보드 버퍼의 메모리 주소를 찾을 것인가 이다. (1) 키보드 버퍼는 로드 가능한 모듈에 의해 직접적으로 접근되지 않게 하기 위해 커널의 심볼 테이블에 노출되지 않는다. (2) 자료구조가 할당된 메모리 공간은 시스템이 부팅될 때, 장치가 다시 꽂혔을 때 매번 달라진다.
일반적으로 로드 가능한 모듈은 메모리를 동적으로 할당한다. 때문에, 객체의 주소는 시스템이 재부팅된 후 같을 필요가 없다. 게다가 운영체제는 공격자가 객체의 주소를 예측하는 것을 못하게 하기 위해 특정 랜덤화 알고리즘을 적용할 수 있다.

키보드의 랜덤 배치를 극복하기 위해 공격자는 메모리 전체를 탐색해야 한다. 결과적으로, 우리의 GPU 기반 키로거는 두 가지 부분으로 구성되어 있다: (1) CPU 기반의 구성요소 - 부트스트랩 과정에서 한번 실행되며 메인메모리의 키보드 버퍼 주소를 찾음. (2) GPU기반의 구성요소 - DMA를 이용하여 모든 키 입력을 기록하고 키보드 버퍼를 감시함. [그림 1]은 부트스트랩 과정(회색), 모니터링 과정(검은색)을 상호작용의 순서와 함께 보여준다.

![](/images/01/figure-02.png)
*그림 2: USB Request Block(URB) 구조체에서 관심있게 봐야 할 필드들*

### 3.1 키보드 버퍼 찾기

리눅스에서 연결된 USB 장치는 리눅스 소스코드의 헤더 파일 `linux/usb.h`에 선언되어 있는 USB Request Block(URB) 구조로 표현된다. [그림 2]는 우리의 목표와 관련된 URB 구조체의 필드들을 보여준다.
특히 USB 키보드 장치의 경우 키보드 버퍼는 `transfer_buffer` 필드로 URB 구조체의 일부이다.
불행히도 URB 구조체가 위치한 메모리 오프셋은 시스템이 재시작될 때마다 변경된다.
[그림 1, 과정 1]에서 처럼 키보드 버퍼의 정확한 오프셋을 찾기 위해 우리는 순차적으로 모든 메모리를 탐색해야 한다.
하지만 윈도우, 리눅스를 포함한 현대 OS에서는 유저가 그들에게 할당되지 않은 메모리 영역에 접근하는 것을 금지하고 있다.
일반적으로, 그 프로세스의 가상 메모리 공간에 할당되지 않은 페이지로의 접근은 위법으로 간주되며 세그먼테이션 폴트를 일으킨다.
OS 커널과, 자료구조가 위치한 메모리 영역에 접근하기 위해 키로거의 메모리 탐색 단계는 관리자 권한으로 실행되어야 한다.

리눅스는 `/dev/mem` 과 `/dev/kmem`과 같은 특별한 파일을 제공한다. 각각은 권한이 있는 유저가 물리메모리, 커널의 가상메모리에 접근할 수 있도록 한다.
보안상의 이유이긴 하지만, 최근 배포판은 기본적으로 이 파일들에 접근할 수 없다; `/dev/mem`, `/dev/kmem` 파일은 `CONFIG_STRICT_DEVMEM=y` 옵션 없이 컴파일된 커널에서만 접근할 수 있다.
대신에 우리는 [그림 1, 과정 2]에서 처럼 호스트의 주 메모리 전체를 탐색할 수 있는 로드 가능한 커널 모듈(LKM)을 구현했다.
그 커널 모듈은 `/dev/mem` 문자 장치와 동일한 메커니즘을 사용하여 물리 페이지에 대한 접근을 구현한다.

![](/images/01/figure-03.png)
*그림 3: 키보드 버퍼를 찾기 위한 수도코드. IF 문의 조건이 만족될 때마다. 잠재적인 URB 구조체가 발견된다. 우리는 transfer_buffer 필드의 값이 키보드 장치와 상응하는 적절한 형태인지 검증한다. 예) 유효한 키값.*

32비트 x86 시스템의 낮은 주소의 메모리를 탐색하는 수도 코드는 [그림 3]에 있다.
이 접근방법은 kmalloc()을 사용하여 할당된 메모리에 적절하며, 항상 물리적 매핑(논리 주소)를 가진 커널 가상 주소를 반환한다.
키보드 버퍼를 찾기 위해 우리는 USB 장치 구조체의 포인터를 찾기 시작한다.
앞서 말한 포인터는 0x400 정도에 맞춰 정렬되며, `transfer_dma`필드는 0x20 정도에 맞춰 정렬된다.
만약 두 조건이 만족된다면, 우리는 `product`필드가 'usb', 'keyboard'(유선 USB 키보드의 경우) 혹은 'usb' 와 'receiver'(무선 USB 마우스/키보드 세트)를 포함하고 있는지를 확인한다.
마지막 단계에서, 우리는 `transfer_buffer_length`필드가 적절한 길이(8byte)를 가지고 있는지 유효한 키 입력 값을 가지고 있는지를 확인한다. 예) 눌린 키가 없다면 모든 바이트는 0이다.
32비트에서 커널 주소 공간은 1GB이다. 최악의 경우에도 검색시간은 약 3.2초이다.

### 3.2 키 입력 캡처

다음 단계는 키보드 장치 드라이버가 사용하는 버퍼의 주소를 갖고, GPU가 지속적으로 버퍼의 값이 바뀌는지를 모니터링 하도록 설정하는 것이다.
이를 위해서 GPU는 반드시 커널의 키보드 버퍼에 접근해야 한다.
NVIDIA CUDA 장치는 GPU를 관리하는 호스트 컨트롤러 프로세스와 통일된 주소 공간을 공유한다.
결과적으로 GPU가 직접 키보드 버퍼에 접근하기 위해서 호스트 프로세스의 메모리 공간에 버퍼의 메모리 공간이 매핑 되어야 한다.
컨트롤러 프로세스의 페이지 테이블을 조작함으로써 [그림1, 과정 3]과 같이 키보드 버퍼가 위치한 페이지를 포함하도록 할 수 있다.

초기화 과정 중에 컨트롤러 프로세스는 `mmap()` 시스템 콜을 사영하여 더미 메모리 페이지를 얻는다.
탐색단계가 완료된 후 부트스트래핑 커널 모듈은 컨트롤러 프로세스의 페이지 테이블을 찾고, 더미 페이지의 테이블을 키보드 버퍼가 포함된 물리 페이지를 가리키도록 변경한다.
[그림 1, 과정 4]처럼 GPU가 버퍼 감시를 시작한 후, 컨트롤러 프로세스는 바로 munmap()을 사용하여 페이지를 할당해제 한다.
그렇게 함으로써 컨트롤러 프로세스는 더 이상 해당 페이지를 참조하지 않게 된다, 따라서 수상한 테이블 매핑을 검사하는 툴을 피할 수 있다.
CPU의 어떠한 간섭도 없이 DMA를 통하여 물리 주소를 사용함으로써 GPU가 키보드 버퍼에 접근하는 기능에 영향을 주지 않는다.
본질적으로 가상매핑은 접근할 수 없는 물리 페이지에 CUDA API가 DMA 접근을 할 수 있게 하기 위해서 처음에만 필요하다.

키입력을 캡처하기 위해 GPU는 지속적으로 버퍼의 변화를 감시한다.
섹션 4에서 논의된 바와 같이, 100ms 미만의 주기는 연속된 접근으로 인한 어떠한 논쟁거리도 없이 최소한의 런타임 오버헤드로 키입력 속도가 빠른 것 까지도 기록할 수 있다.
버퍼의 크기는 8바이트이다.
첫 번째 바이트는 `Alt`, `Shift`, `Ctrl`과 같은 조합키의 코드에 해당된다.
만약 동시에 한개 이상의 조합키가 눌린다면, 이 값은 각각의 코드의 합으로 변환된다.
두 번째 바이트는 특별한 의미를 갖고 있지 않다.
나머지 여섯 바이트는 조합키를 제외한 나머지 키의 코드를 나타낸다.
항상 버퍼는 눌려진 키를 나타내는 한 개에서 여섯 개의 0이 아닌 값을 갖는다.
유저가 키(혹은 키의 조합)를 누를 때마다, 그에 상응하는 키코드는 버퍼에 쓰여진다. 그리고 입력된 키 값은 남아있는다.
사용자가 눌렀던 키를 뗄 때. 값은 0이 된다.
몇몇 키가 동시에 눌릴 때 에러 상태가 발생하고 두 개의 0과 여섯 개의 1로 표현된다.

캡처된 키는 간단한 디스패쳐를 사용하여 ASCII 문자의 값으로 변환된다. 그리고 GPU의 장치 메모리에 저장된다.
현대 GPU는 수백 MB에서 2~3GB의 메모리를 가지고 있다. 그것은 기록된 키 입력들을 저장하기에 충분하다.
더욱이 현대 GPU의 병렬 처리 성능은 기록된 데이터를 분석 하는 것에 이용될 수 있다. 예를 들어 신용카드 정보나 은행 인증과 같은 민감한 데이터들이 이에 해당된다.
우리는 기존에 있는 GPU 기반의 패턴 매칭 구현체를 이용하여 주기적으로 입력된 키와 간단한 정규식 표현을 매칭하는 모듈을 만들었다.
섹션 4에서 언급한 것처럼, GPU는 사용자가 하나의 키를 누르는 시간보다 더 적은 시간으로 수십 MB를 매칭할 수 있다.



## 4. 평가

GPU 기반 키로거의 프로토타입을 평가하기 위해 우리는 4GB의 메모리, Intel E6750 2.66GHz 듀얼 코어 CPU가 탑재된 컴퓨터를 사용하였다.
우리는 저 사양의 GT630부터 고 사양의 GTX480 까지 몇몇 NVIDIA 그래픽 카드를 사용하였다.
우리의 데스크탑은 Ubuntu 12.10에 커널 버전 3.5.0이 돌아가며 CUDA의 명령줄 프로파일러 기능을 이용하여 GPU의 실행 시간을 측정하였다.

첫 번째 실험에서 우리는 키로거의 CPU, GPU 사용량을 측정하였다.
CPU 시간은 주기적으로 GPU 드라이버가 제공하는 간단한 함수를 호출하는 컨트롤러 프로세스에 해당하며 GPU 커널 함수를 호출하는 기능을 한다.률
GPU 커널 함수는  키보드 이벤트 버퍼를 읽고 가끔 간단한 데이터 분석 작업을 하고 그 값을 컨트롤러 프로세스에 반환하고 명시된 시간 동안 유휴 상태로 만든다.
이 방식은 GPU가 그래픽 렌더링에 쓰여야 하기 때문에 필요하다. 또한, 긴 실행 시간은 적절한 그래픽 표시에 영향을 미친다.
더욱 중요한 것은 현재의 GPU는 작업 중인 일이 방해되면 안 되기 때문에 비선점 스케줄링을 사용한다.

![](/images/01/figure-04.png)
*그림 4: 커널 호출 주기에 따른 CPU 사용률*

![](/images/01/figure-05.png)
*그림 5: 커널 호출 주기에 따른 GPU 사용률*

이것은 매우 흥미로운 트레이드 오프를 보여준다. 커널 함수의 호출 빈도가 증가하면 CPU 및 GPU의 오버헤드가 증가하고 이는 유저가 알아차릴 정도의 그래픽 표시에 영향을 줄 위험이 있다.
반면에 그래픽 렌더링에 영향을 미치지 못할 만큼 커널 호출의 빈도가 작다면 놓치는 키 입력이 있을 수 있다.
일반적으로 단일 키 누르기의 지속 시간은 빠른 입력자의 경우 100ms에서 느린 입력자의 경우 1초 이상까지 다양하다.
결과적으로 놓치는 것 없이 모든 키입력을 정확하게 감시하기 위해서는 GPU 호출 간격을 반드시 100ms 이하로 하여야 한다.
두 그림에 나타난 것처럼, 우리는 최소한의 영향을 미치는 90ms의 주기를 선택하였다: CPU 사용율은 약 0.1%(그림 4)인 반면 GPU는 5·10<sup>-5</sup> (그림 5)의 무시할만한 사용률을 갖는다.
GPU가 PCIe 버스를 통하여 8바이트 길이의 키보드 버퍼를 읽기 위해 걸리는 시간은 약 0.005ms이다.

![](/images/01/table-01.png)
*표 1: 다양한 형태의 신용카드 번호를 매칭하는 정규표현식*

![](/images/01/figure-06.png)
*그림 6: 표 1의 정규표현식을 사용하여 신용카드 번호를 추출할 때, 버퍼 사이즈에 따른 그래픽 카드별 실행시간*

다음 실험에서 우리는 GPU가 캡처된 데이터를 조사하고 민감한 정보를 추출하는데 걸리는 시간을 측정하였다.
특히, 우리는 (표 1)에 나온 정규표현식을 이용하여 다양한 신용카드 번호를 기록된 데이터를 찾는다.
(그림 6)은 다양한 입력 크기에 따른 GPU 실행시간을 보여준다.
우리는 버퍼 크기가 MB 수준에서도 실행시간이 1ms 미만임을 알 수 있다.
이와 같이, 일반 사용자가 수백 바이트를 입력하는데 몇 초가 소요되므로 탐색하는 오버헤드는 무시할 수 있다.
데이터 분석은 새로운 데이터의 수 MB가 쌓인 후에 하는 식으로 자주 수행되지 않을 수 있다.

## 5. 대응책

현재 멀웨어 분석 및 탐지 시스템은 오로지 CPU 아키텍쳐에 맞추어져 있다. 따라서 GPU 기반 멀웨어에 대해 비효율적이다.
하지만 GPU에서 돌아가는 악성 코드는 몇몇 방법에 의해서 판별될 수 있다.
GPU 기반의 멀웨어를 판별하기 위해 기존의 방어책은 GPU 기계어를 분석하는 새로운 기능을 향상 시킬 필요가 있다.

### 5.1 GPU 코드 분석

NVIDIA는 최근 CUDA 어플리케이션의 두 가지 디버깅 툴 `cuda-gdb`와 `cuda-memcheck`를 공개하였다.
`cuda-memcheck`는 런타임 메모리 에러를 검사하는 가벼운 메커니즘을 제공한다. `cuda-gdb`는 `gdb`와 유사하게 GPU에서 실제로 돌아가는 CUDA 어플리케이션을 실시간으로 디버깅할 수 있다.
5.0 버전 이래로 `cuda-gdb`는 돌아가는 프로세스를 어태치할 수 있고, GPU의 특정 상태를 조사할 수 있다.
하지만 공격자는 쉽게 악성코드의 디버그 심볼을 스트립 할 수 있고 이것의 분석을 복잡하게 할 수 있다.
여전히 GPU 코드의 기본적인 디버깅 지원은 GPU 기반의 멀웨어 바이너리를 분석하는 첫걸음이 될 것이다.
예를 들어 유명한 프로세서 구조가 부동소수점 연산 혹은 특별한 연산을 위해 명령어를 확장할 때마다. 악성코드는 곧바로 탐지와 분석을 방해하기 위해 이를 이용하는 상황이 계속 반복되었다.

가상머신 환경위에 구축된 멀웨어 분석 시스템의 중요한 고려사항은 그래픽 장치 에뮬레이션 대신 GPGPU API를 적절하게 지원하는 것이다.
가상머신은 호스트 시스템의 실제 그래픽 카드와 게스트 OS에 제공되는 에뮬레이트된 그래픽카드 사이에 가상화 계층을 제공하므로 다중의 가상머신이 같은 장치에 접근할 수 있다.
따라서 기존 가상머신에서 실행할 때 GPGPU 어플리케이션은 가상 그래픽카드의 드라이버가 어떠한 GPGPU API도 지원하지 않기 때문에 실행되지 않는다.
최근 연구는 가상머신 안에서 GPU 가시성을 제공하는 가상환경을 제안했다.
불행히도 이려한 연구의 목적은 그래픽 프로세서를 시뮬레이팅 하기보다는 다중화 및 대기열 방법을 이용하여 서로 다른 어플리케이션 간에 GPU를 공유하는 것을 가능케 하는 것이다.
후자의 접근방법은 악의적인 GPU 커널의 행동을 추정하는 데 중요하다.

### 5.2 런타임 탐지

GPU 기반의 악성코드 탐지하기 위한 가능한 방법은 DMA 부수 효과 관찰에 기반할 수 있다.
Stewin et al은 DMA 멀웨어가 확실하게 측정될 수 있는 부수효과를 갖는 것을 보였다.
그러나 제안된 기술은 다량의 DMA 전송을 수행하는 DMA 멀웨어에만 효과가 있다. 예를 들어 공격을 수행하기 위해 가치 있는 데이터를 메모리에서 지속적으로 검색하는 경우이다.
GPU 기반의 키로거는 어떠한 다량의 전송도 수행할 필요가 없으므로 이 기술이 효과적인 방어로 적용될 수 있을지는 미지수이다.
그 대신에 이것의 접근 패턴을 모니터링 하거나 GPU 사용량의 프로파일에 기반으로 방어가 가능하다.

## 6. 고찰

우리의 GPU 기반 키로거 프로토타입의 중요한 한계점은 이것의 실행을 위해 CPU 프로세스가 필요한 것이다.
CPU 코드의 유일한 목적은 주기적으로 몇 가지 기계어로 작성하여 최소한의 메모리 흔적을 남기는 작업을 하는 악의적인 GPU 커널을 실행하는 것이다.
예를 들어 현재 프로토타입의 바이너리 사이즈는 4KB 미만이다.
이것은 공격자가 정상 유저 레벨 프로세스의 주소 공간에 키로거를 인젝션 함으로써 쉽게 숨기는 것을 가능케 한다.
프로토타입 구현의 다른 한계점은 GPU가 키보드 버퍼를 감시하게 하기 위해 초기화 과정에 관리자 권한이 필요하다는 것이다.
하지만 실행에 관리자 권한이 필요한 코드는 오로지 키보드 버퍼의 주소를 획득하고 GPU가 물리 페이지에 접근할 수 있게 한 뒤 완전히 제거된다.
반면에 기존의 루트킷과 커널 레벨 키로거와는 달리 코드 후킹이나 존재가 감춰진 자료구조를 다룰 필요가 전혀 없다.
GPU가 지속적으로 모든 키보드 활동을 감시하는 동안 커널 코드와 자료구조는 온전하게 유지된다.
섹션 3에서 언급한 것처럼 프로토타입은 커널에서 코드를 실행하기 위해 로드가능한 커널 모듈을 사용한다.
우리는 오로지 편의를 위해 선택되었으며 커널 레벨 루트킷 설치에 일반적으로 사용되는 것과 같은 은닉 방법도 사용될 수 있다. (예: 취약점을 이용하여 커널에 직접 악성코드를 인젝션하는 방법)

## 7. 결론 및 제안

이 논문에서 그래픽 프로세스에서 직접 돌아가는 CPU에서 실행되고 CPU에 맞게 짜여진 현재의 보호 기법을 우회하는 은닉 키로거를 보였다.
우리는 저사양 그래픽카드와 고사양 그래픽 카드 모두에서 GPU 기반 키로거를 평가하고 구현하였다.
현대의 그래픽 프로세서의 구조는 키 입력을 기록하는 것 외에도 프로토타입에 캡처된 데이터를 분석하기 위한 과도한 연산 성능을 주었다.
이 능력을 증명하기 위해 프로토타입은 켑쳐된 키입력으로부터 무시할만한 런타임 오버헤드로 신용카드 번호를 추출하기 위해 GPU의 스트리밍 프로세서를 사용하였다.

현재 우리의 GPU 키로거는 호스트 메모리에 작은 흔적을 남기며, 약 0.1%에 해당하는 CPU와 GPU 사용률을 보인다.
이러한 특성은 은닉성과 기존의 방어에 대항하는 기대치를 높일 수 있다.
우리는 GPU 기반 키로거가 런타임 시 감염된 호스트로부터 민감한 데이터를 추출하기 위한 은닉 방법을 제공하는 루트킷의 일부가 될 수 있다고 결론지었다.
우리의 작업은 그래픽 프로세서에서 실행되는 악성코드를 효율적으로 방어하기 위한 추가적인 보호 방법이 필요함을 분명히 보여준다.
제안의 일부분으로써 윈도우에 해당하는 프로토타입 구현, 암호키와 웹뱅킹 인증, 웹캠 사진, 스크린샷, 파일케시에 있는 열린 문서와 같은 민감한 데이터 취득을 포함한 다른 악의적인 행위를 할 수 있는 유사한 기능 개발을 계획했다.